# 文化速读功能实现经验总结

## 一、本次任务概览

- **目标**：完善「文化速读」板块，迁移到 Supabase，并保持前端动态展示。
- **主要工作**：
  - 设计并创建 `culture_articles` 等表结构
  - 批量导入 20 篇蓝染主题文章
  - 确保 `/culture` 与 `/culture/[slug]` 正常从 Supabase 读取数据
  - 记录 SQL 执行中遇到的问题与排查经验

---

## 二、实际操作步骤（简版流程）

1. **创建表结构**
   - 在 Supabase SQL Editor 中执行：`supabase/culture-articles-schema.sql`
   - 内容包括：`culture_articles`、`article_favorites`、`article_comments` 表，以及索引和 RLS 策略。

2. **导入文章数据**
   - 执行 `add-culture-articles-part1.sql`（前 10 篇）
   - 执行 `add-culture-articles-part2.sql`（后 10 篇）
   - 每次执行应返回 `10 rows inserted`

3. **验证数据**
   - 使用：
     ```sql
     SELECT COUNT(*) FROM culture_articles;
     ```
   - 期望结果：`20`

4. **前端验证**
   - 访问 `/culture`：查看列表、精选/最新/热门、分类筛选
   - 点击文章卡片到 `/culture/[slug]`：查看详情

---

## 三、遇到的问题 & 解决方案

### 1. `column "category" does not exist`

- **现象**：执行 schema 脚本时，创建 `category` 索引报错：
  ```sql
  ERROR: 42703: column "category" does not exist
  ```
- **原因**：
  - 数据库中已经存在旧版本的 `culture_articles` 表
  - 旧表结构中缺少 `category` 等新字段，导致后续 `CREATE INDEX ... (category)` 失败
- **解决方案**：
  - 方案 A（安全补齐）：
    ```sql
    ALTER TABLE public.culture_articles
      ADD COLUMN IF NOT EXISTS category TEXT NOT NULL DEFAULT '历史',
      ADD COLUMN IF NOT EXISTS tags TEXT[] DEFAULT '{}',
      ADD COLUMN IF NOT EXISTS read_time INTEGER DEFAULT 5,
      ADD COLUMN IF NOT EXISTS author TEXT DEFAULT '世说蓝语',
      ADD COLUMN IF NOT EXISTS views INTEGER DEFAULT 0,
      ADD COLUMN IF NOT EXISTS likes INTEGER DEFAULT 0,
      ADD COLUMN IF NOT EXISTS status TEXT DEFAULT 'published',
      ADD COLUMN IF NOT EXISTS featured BOOLEAN DEFAULT false,
      ADD COLUMN IF NOT EXISTS updated_at TIMESTAMP WITH TIME ZONE DEFAULT NOW();
    ```
  - 方案 B（需要确认无数据）：删除旧表后重新执行 schema。

> **经验**：如果有「字段不存在」错误，先确认线上表结构，再决定是用 `ALTER TABLE` 补齐，还是重建表。

---

### 2. `invalid input syntax for type uuid`

- **现象**：执行插入脚本时报错：
  ```sql
  ERROR: 22P02: invalid input syntax for type uuid: "art11111-1111-1111-1111-111111111111"
  ```
- **原因**：
  - `id` 字段是 UUID 类型
  - 原始脚本中使用了类似 `art11111-...` 的伪 UUID，包含非十六进制字符 `t`
- **修复方式**：
  - 将所有 `artxxxxx-...` 替换为**合法的 UUID**，例如：
    - `a1111111-1111-1111-1111-111111111111`
    - `a2222222-2222-2222-2222-222222222222`
    - `b1111111-1111-1111-1111-111111111111`
  - 或者**更简单**：在 INSERT 中**不显式指定 `id`** 字段，让数据库使用 `DEFAULT gen_random_uuid()` 自动生成。

> **经验**：UUID 字段要么：
> - 使用数据库默认值（最省心）；
> - 要么保证是合法的 `xxxxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxxxx` 且只包含 `[0-9a-f]`。

---

### 3. `COUNT(*) = 22`：数据条数与预期不符

- **现象**：导入完成后执行：
  ```sql
  SELECT COUNT(*) FROM culture_articles;
  ```
  返回 `22`，而不是预期的 `20`。
- **可能原因**：
  - 在导入前数据库中已经存在测试数据或旧数据
  - 插入脚本被执行了多次，部分记录未命中 `ON CONFLICT` 条件
- **排查方法**：
  - 按 `slug` 检查是否有非预期文章：
    ```sql
    SELECT id, slug, title
    FROM culture_articles
    ORDER BY created_at;
    ```
  - 或排除本次 20 篇已知 slug，看看还剩什么：
    ```sql
    SELECT id, slug, title
    FROM culture_articles
    WHERE slug NOT IN (...20 个 slug...);
    ```
- **处理方式**：
  - 方法 A：清空表后重导（最干净）：
    ```sql
    DELETE FROM culture_articles;
    -- 再依次执行 Part1 / Part2
    ```
  - 方法 B：只删除多余记录（通过 slug 精准删除）。

> **经验**：批量导入后，**一定要用 `COUNT(*)` 和 `slug` 列表做一次校验**，确认没有重复或脏数据。

---

## 四、小经验总结

1. **顺序很重要**：
   - 先执行 schema（建表/加字段/索引）
   - 再执行数据插入脚本

2. **保持 schema 一致**：
   - 本地 `.sql` 文件是「设计稿」，Supabase 实际表结构是「真相」
   - 碰到字段错误时，优先对比两者的差异

3. **插入脚本尽量幂等**：
   - 使用 `ON CONFLICT (id) DO NOTHING` 或基于 `slug` 的冲突处理
   - 方便重复执行脚本，而不产生重复数据

4. **错误码可以快速定位问题**：
   - `42703`：列不存在（多半是 schema 不一致）
   - `22P02`：类型转换错误（如 UUID 格式不对）
   - 通过错误码可以更快判断是「结构问题」还是「数据问题」。

5. **适合写成文档的场景**：
   - 新增一块业务（如文化速读）
   - 涉及数据库变更 + 批量导入
   - 中间踩到明显的坑（字段、UUID、重复数据）

---

## 五、后续可以优化的方向

- 在脚本中加入简单的「验证查询」示例，方便执行完立刻自检
- 在文档中维护一份「所有文章 slug 列表」，对比数据库更直观
- 考虑将固定数据迁移到专门的 seed 机制或自动化脚本中执行

> 本文件只做**简短经验记录**，更详细的设计与操作步骤见：
> - `docs/CULTURE_ARTICLES_GUIDE.md`
> - `docs/CULTURE_QUICK_START.md`
