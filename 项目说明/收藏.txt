使用 Supabase 来为您的应用实现收藏功能并实时显示数据是一个非常合适的选择。Supabase 强大的实时（Realtime）功能可以轻松满足您的需求。[1][2]
下面我将为您提供一个详细的步骤指南，包括数据库设计、API 调用以及如何实现实时数据显示。
第一步：数据库设计与准备
首先，我们需要在 Supabase 中创建一张表来存储用户的收藏记录。一个常见的做法是建立一个关联表，记录哪个用户收藏了哪个项目。
登录您的 Supabase 项目后台。
进入 “Table Editor” 页面，点击 “New table” 创建新表。
创建一张名为 favorites （或您喜欢的任何名称）的表，并添加以下列：
id: bigint 类型，作为主键，可以设置为自增。
user_id: uuid 类型，用于关联到进行收藏的用户。这个 uuid 应该与 Supabase auth.users 表中的用户 id 相对应。
item_id: bigint (或其他合适的 ID 类型)，用于关联到被收藏的项目（例如商品、文章等）。您需要确保这个 ID 能唯一标识您应用中的一个项目。
created_at: timestamp with time zone 类型，记录收藏的时间，可以设置默认值为 now()。
设置外键关联（可选但推荐）：
将 user_id 列设置为 auth.users 表 id 列的外键，确保数据完整性。
将 item_id 列设置为您项目中项目表的 ID 列的外键。
开启行级安全策略 (Row Level Security - RLS):
为了数据安全，您必须为 favorites 表开启 RLS。[3] 这能确保用户只能访问和操作自己的收藏数据。[4]
进入 “Authentication” -> “Policies” 页面，为 favorites 表创建新策略。
允许用户读取自己的收藏记录:
策略名称：Allow individual read access
允许个人读取权限
USING 表达式: auth.uid() = user_id
USING 表达式： auth.uid（） = user_id

允许用户插入自己的收藏记录:
策略名称：Allow individual insert access
允许个人插入访问
WITH CHECK 表达式: auth.uid() = user_id
WITH CHECK 表达式： auth.uid（） = user_id

允许用户删除自己的收藏记录:
策略名称：Allow individual delete access
策略名称： 允许个人删除访问

USING 表达式: auth.uid() = user_id
USING 表达式： auth.uid（） = user_id

第二步：实现收藏与取消收藏的 API 功能
接下来，我们将在您的应用代码中（通常是前端）调用 Supabase 的 API 来实现添加、移除和查询收藏的功能。这里以 JavaScript 为例：
初始化 Supabase Client  初始化 Supabase 客户端
首先，确保您已经在项目中安装并初始化了 Supabase 的 JavaScript 客户端。
code
JavaScript
import { createClient } from '@supabase/supabase-js'

const supabaseUrl = '您的项目URL'
const supabaseKey = '您的API密钥'
const supabase = createClient(supabaseUrl, supabaseKey)```

**1. 添加收藏**

```javascript
async function addFavorite(itemId) {
  const { data: { user } } = await supabase.auth.getUser();
  if (!user) {
    console.error('用户未登录');
    return;
  }

  const { data, error } = await supabase
    .from('favorites')
    .insert([
      { user_id: user.id, item_id: itemId }
    ]);

  if (error) {
    console.error('添加收藏失败:', error);
  } else {
    console.log('添加收藏成功:', data);
  }
}
2. 取消收藏
code
JavaScript
async function removeFavorite(itemId) {
  const { data: { user } } = await supabase.auth.getUser();
  if (!user) {
    console.error('用户未登录');
    return;
  }

  const { data, error } = await supabase
    .from('favorites')
    .delete()
    .eq('user_id', user.id)
    .eq('item_id', itemId);

  if (error) {
    console.error('取消收藏失败:', error);
  } else {
    console.log('取消收藏成功');
  }
}
3. 获取用户的收藏列表
code
JavaScript
async function getFavorites() {
  const { data: { user } } = await supabase.auth.getUser();
  if (!user) {
    console.error('用户未登录');
    return [];
  }

  const { data, error } = await supabase
    .from('favorites')
    .select('item_id') // 您也可以选择其他需要返回的字段
    .eq('user_id', user.id);

  if (error) {
    console.error('获取收藏列表失败:', error);
    return [];
  } else {
    return data;
  }
}
第三步：调用 API 实时显示收藏夹数据
这是实现实时显示的关键。Supabase 提供了强大的实时订阅功能，可以直接监听数据库的变化。
[5][6]
在您的项目中开启 favorites 表的实时广播：
进入 Supabase 后台的 “Database” -> “Replication” 页面。
找到您的 public schema，并为 favorites 表开启 INSERT, UPDATE, 和 DELETE 的广播。
在您的应用中订阅 favorites 表的变化：
您可以在页面加载时获取一次完整的收藏列表，然后通过订阅来实时更新。
code
JavaScript
// 假设您有一个状态来存储收藏列表，例如在 React 中
// const [favorites, setFavorites] = useState([]);

// 初始加载收藏列表
async function initialLoadFavorites() {
  const initialFavorites = await getFavorites();
  // setFavorites(initialFavorites);
  console.log('初始收藏列表:', initialFavorites);
}

initialLoadFavorites();

// 创建一个唯一的频道
const channel = supabase.channel('favorites-channel');

// 订阅数据库变化
channel
  .on(
    'postgres_changes',
    {
      event: '*', // 监听所有事件 (INSERT, UPDATE, DELETE)
      schema: 'public',
      table: 'favorites',
    },
    (payload) => {
      console.log('数据库发生变化:', payload);

      // 根据变化的类型更新您的收藏列表状态
      if (payload.eventType === 'INSERT') {
        // 有新的收藏，将 payload.new 添加到您的收藏列表中
        // setFavorites(currentFavorites => [...currentFavorites, payload.new]);
      } else if (payload.eventType === 'DELETE') {
        // 有收藏被取消，从您的收藏列表中移除 payload.old
        // setFavorites(currentFavorites => currentFavorites.filter(fav => fav.id !== payload.old.id));
      }
      
      // 在这里更新您的UI
    }
  )
  .subscribe((status) => {
    if (status === 'SUBSCRIBED') {
      console.log('已成功订阅收藏夹变化！');
    }
  });

// 当组件卸载或页面离开时，记得取消订阅
// return () => supabase.removeChannel(channel);
总结
通过以上三个步骤，您就可以利用 Supabase 成功实现一个功能完善且数据实时的收藏功能：
数据库层面：建立清晰的 favorites 表来管理用户和收藏项目之间的关系，并通过行级安全策略保证数据安全。
API 调用层面：通过 Supabase 提供的客户端库，轻松实现收藏的增、删、查操作。
实时数据层面：利用 Supabase 的 Realtime 功能，订阅数据库 favorites 表的变化，从而在数据发生变动时，无需用户刷新页面即可实时更新应用的界面。
[7][8]
这个方案充分利用了 Supabase 作为后端即服务 (BaaS) 的优势，让您可以更专注于前端应用的开发，而无需编写复杂的后端逻辑。

通用方法完全适用于 Next.js 14 的 App Router 架构，但这需要结合 App Router 的核心概念——服务器组件 (Server Components) 和 客户端组件 (Client Components)——来进行调整。
实时数据显示功能，由于需要利用浏览器 API (WebSocket) 和 React 的 Hooks (如 useEffect)，必须在客户端组件中实现。
下面是为您量身定制的、在 Next.js 14 App Router 中实现实时收藏功能的详细步骤。
预备步骤：数据库和 Supabase 项目设置
这一步与之前的回答完全相同。请确保您已经：
在 Supabase 中创建了 favorites 表。
为该表设置了行级安全策略 (RLS)，允许用户读写自己的数据。
在 Supabase 后台的 “Database” -> “Replication” 中，为 favorites 表开启了实时广播 (replication)。[1]
第一步：在 Next.js 14 中配置 Supabase 客户端
在 App Router 中，我们需要区分在客户端还是服务器上创建 Supabase 客户端。推荐使用官方的 @supabase/ssr 包来简化这个过程。[2][3]
安装依赖:
code
Bash  巴什
npm install @supabase/supabase-js @supabase/ssr
设置环境变量:
在项目根目录创建 .env.local 文件，并填入您的 Supabase 项目信息：
code
Code  法典
NEXT_PUBLIC_SUPABASE_URL=你的项目URL
NEXT_PUBLIC_SUPABASE_ANON_KEY=你的API密钥
创建客户端工具函数:
在您的项目中创建一个工具文件夹，例如 lib/supabase/，并在其中创建两个文件：
lib/supabase/client.ts (用于客户端组件)
code
TypeScript
import { createBrowserClient } from '@supabase/ssr'

export function createClient() {
  return createBrowserClient(
    process.env.NEXT_PUBLIC_SUPABASE_URL!,
    process.env.NEXT_PUBLIC_SUPABASE_ANON_KEY!
  )
}
lib/supabase/server.ts (用于服务器组件和 Server Actions)
lib/supabase/server.ts （用于服务器组件和 Server Actions）

code
TypeScript
import { createServerClient } from '@supabase/ssr'
import { cookies } from 'next/headers'

export function createClient() {
  const cookieStore = cookies()

  return createServerClient(
    process.env.NEXT_PUBLIC_SUPABASE_URL!,
    process.env.NEXT_PUBLIC_SUPABASE_ANON_KEY!,
    {
      cookies: {
        get(name: string) {
          return cookieStore.get(name)?.value
        },
      },
    }
  )
}
第二步：实现收藏与取消收藏 (使用 Server Actions)
在 App Router 中，执行数据变更操作（如添加或删除收藏）的最佳方式是使用 Server Actions。这样可以确保逻辑在服务器端安全执行。
创建 Server Action 文件 (app/actions.ts):
创建 Server Action 文件 （app/actions.ts）：

code
TypeScript
'use server'

import { revalidatePath } from 'next/cache'
import { createClient } from '@/lib/supabase/server' // 使用服务器客户端

// 添加收藏 Action
export async function addFavorite(itemId: number) {
  const supabase = createClient()

  const { data: { user } } = await supabase.auth.getUser()
  if (!user) {
    throw new Error('用户未登录，无法添加收藏')
  }

  const { error } = await supabase
    .from('favorites')
    .insert({ item_id: itemId, user_id: user.id })

  if (error) {
    console.error('添加收藏失败:', error)
    throw new Error('添加收藏失败')
  }

  revalidatePath('/favorites') // 可选：让收藏页面数据重新生效
  console.log('添加收藏成功')
}

// 取消收藏 Action
export async function removeFavorite(itemId: number) {
  const supabase = createClient()

  const { data: { user } } = await supabase.auth.getUser()
  if (!user) {
    throw new Error('用户未登录，无法取消收藏')
  }

  const { error } = await supabase
    .from('favorites')
    .delete()
    .match({ item_id: itemId, user_id: user.id })

  if (error) {
    console.error('取消收藏失败:', error)
    throw new Error('取消收藏失败')
  }

  revalidatePath('/favorites') // 可选：让收藏页面数据重新生效
  console.log('取消收藏成功')
}
第三步：创建实时显示的收藏夹组件
现在，我们将创建一个客户端组件来实时监听 favorites 表的变化并更新 UI。
创建父级服务器组件 (例如 app/favorites/page.tsx)
这个组件负责在服务器端首次加载用户的收藏列表，然后将数据传递给客户端组件。
code
Tsx
import { createClient } from '@/lib/supabase/server'
import FavoritesRealtime from './FavoritesRealtime'

export default async function FavoritesPage() {
  const supabase = createClient()
  const { data: { user } } = await supabase.auth.getUser()

  // 在服务器上获取初始收藏数据
  const { data: initialFavorites } = await supabase
    .from('favorites')
    .select('*')
    .eq('user_id', user?.id ?? '')

  return (
    <div>
      <h1>我的收藏夹</h1>
      {/* 将服务器获取的初始数据传递给客户端组件 */}
      <FavoritesRealtime serverFavorites={initialFavorites ?? []} />
    </div>
  )
}
创建实时更新的客户端组件 (例如 app/favorites/FavoritesRealtime.tsx)
这是实现实时功能的核心。它接收来自服务器的初始数据，然后使用 useEffect 订阅 Supabase 的实时频道。
code
Tsx
'use client'

import { useState, useEffect } from 'react'
import { createClient } from '@/lib/supabase/client' // 使用客户端
import { addFavorite, removeFavorite } from '../actions' // 导入 Server Actions

// 假设 Favorite 的类型
type Favorite = {
  id: number;
  user_id: string;
  item_id: number;
};

export default function FavoritesRealtime({ serverFavorites }: { serverFavorites: Favorite[] }) {
  const [favorites, setFavorites] = useState(serverFavorites)
  const supabase = createClient()

  useEffect(() => {
    // 确保组件挂载后才执行订阅
    const channel = supabase
      .channel('favorites-realtime-channel')
      .on(
        'postgres_changes',
        {
          event: '*',
          schema: 'public',
          table: 'favorites',
        },
        (payload) => {
          console.log('数据库变化:', payload)
          
          if (payload.eventType === 'INSERT') {
            // 将新收藏添加到状态中
            setFavorites((currentFavorites) => [...currentFavorites, payload.new as Favorite])
          } else if (payload.eventType === 'DELETE') {
            // 从状态中移除被取消的收藏
            const deletedFavoriteId = (payload.old as Favorite).id
            setFavorites((currentFavorites) =>
              currentFavorites.filter((fav) => fav.id !== deletedFavoriteId)
            )
          }
        }
      )
      .subscribe()

    // 关键：在组件卸载时，一定要取消订阅以防止内存泄漏[[4](https://www.google.com/url?sa=E&q=https%3A%2F%2Fvertexaisearch.cloud.google.com%2Fgrounding-api-redirect%2FAUZIYQHKnW0wwz4MFDzyvWC82AdfEBBFnC4bB6K3MXnHLoHVIUFiXQjd4vAljmGa4ilm1C4--GwjQB0Ti8eTWLRoBrPgIihBxxTg2AXIkzarLVx60PgzjRLbwLJ3vgNbYXFvBUV8aMwQU54x_1sBXATmTIUxIord2ShPma9S51ULa6tKWZnayFgz6m6-qAyzlr5KMYRk33kYsY2Y16k%3D)][[5](https://www.google.com/url?sa=E&q=https%3A%2F%2Fvertexaisearch.cloud.google.com%2Fgrounding-api-redirect%2FAUZIYQHN5ss_ptpY7K2e9G0kd-pOs2jgW74cMQllhLXZuICXoUXvYyHc7m13hcUG-tBUo1Fu1AYSAfoLWOkoAblHdKf3wysMjp4p2taeA9SLWdEUOeGKaum1yBfKJDivGgHjz6l-rgM1R5xMe4hQXI0hgyyEKdco2fNVx-3jbRqdz-NVkanIu1sTahH2yw95rQ%3D%3D)][[6](https://www.google.com/url?sa=E&q=https%3A%2F%2Fvertexaisearch.cloud.google.com%2Fgrounding-api-redirect%2FAUZIYQGhr0tDLtIEWoWkCIXOnZEiVzOQAB84QeoWJ7uA1LyAbkZ4vAKun37BXF24Yq1MOcX4gAdWqauNYWbHKMoOnmD1Kz4R4i2dRQ6BluJsdx6-JKbao7kbuisfkLbIkYjUdyda1LBY8UmCOOtN0Jby5cCbVrHAJ4uFZLiCPgVzgLdrLqPwzB9nFCZw)]
    return () => {
      supabase.removeChannel(channel)
    }
  }, [supabase]) // 依赖项数组中包含 supabase 实例

  // 示例：一个虚拟的项目列表
  const allItems = [{ id: 101, name: '商品A' }, { id: 102, name: '文章B' }, { id: 103, name: '视频C' }]

  const favoriteItemIds = new Set(favorites.map(f => f.item_id));

  return (
    <div>
      <h2>项目列表</h2>
      <ul>
        {allItems.map(item => (
          <li key={item.id}>
            {item.name} -
            {favoriteItemIds.has(item.id) ? (
              <button onClick={() => removeFavorite(item.id)}>取消收藏</button>
            ) : (
              <button onClick={() => addFavorite(item.id)}>点击收藏</button>
            )}
          </li>
        ))}
      </ul>

      <h2>实时收藏列表 (实时更新)</h2>
      <ul>
        {favorites.map((fav) => (
          <li key={fav.id}>收藏的项目ID: {fav.item_id}</li>
        ))}
      </ul>
    </div>
  )
}
总结与流程梳理
通过结合 Next.js 14 App Router 的特性，我们实现了一个高效且安全的实时收藏功能：
页面加载：用户访问 /favorites 页面，服务器组件 FavoritesPage 首先运行，从数据库中获取当前用户的完整收藏列表。
数据传递：服务器组件将获取到的 initialFavorites 数据作为 prop 传递给客户端组件 FavoritesRealtime。
实时订阅：FavoritesRealtime 组件在浏览器中渲染，它的 useEffect hook 运行，向 Supabase 发起一个实时订阅请求，开始监听 favorites 表的所有变化。
用户操作：当用户点击“收藏”或“取消收藏”按钮时，会触发相应的 Server Action。
后台处理：Server Action 在服务器上安全地执行数据库的 insert 或 delete 操作。
实时广播：数据库的变更被 Supabase 的 Realtime 服务捕捉到，并向所有订阅了该表的客户端广播一个消息（payload）。
前端更新：FavoritesRealtime 组件接收到广播消息，on() 方法中的回调函数被触发，根据 payload 的类型（INSERT 或 DELETE）来更新组件的本地 favorites 状态，UI 从而实现无需刷新页面的实时更新。